/*
 * generated by Xtext 2.25.0
 */
package xtext.sales.assignment3.transaction.serializer;

import assignment2.AdditionalCharge;
import assignment2.Address;
import assignment2.Assignment2Package;
import assignment2.Card;
import assignment2.Cashier;
import assignment2.Company;
import assignment2.Customer;
import assignment2.Discount;
import assignment2.Item;
import assignment2.LineItem;
import assignment2.Price;
import assignment2.Store;
import assignment2.Tax;
import assignment2.Transaction;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import xtext.sales.assignment3.transaction.services.SalesTransactionGrammarAccess;

@SuppressWarnings("all")
public class SalesTransactionSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SalesTransactionGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Assignment2Package.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Assignment2Package.ADDITIONAL_CHARGE:
				sequence_AdditionalCharge(context, (AdditionalCharge) semanticObject); 
				return; 
			case Assignment2Package.ADDRESS:
				sequence_Address(context, (Address) semanticObject); 
				return; 
			case Assignment2Package.CARD:
				sequence_Card(context, (Card) semanticObject); 
				return; 
			case Assignment2Package.CASHIER:
				sequence_Cashier(context, (Cashier) semanticObject); 
				return; 
			case Assignment2Package.COMPANY:
				sequence_Company(context, (Company) semanticObject); 
				return; 
			case Assignment2Package.CUSTOMER:
				sequence_Customer(context, (Customer) semanticObject); 
				return; 
			case Assignment2Package.DISCOUNT:
				sequence_Discount(context, (Discount) semanticObject); 
				return; 
			case Assignment2Package.ITEM:
				sequence_Item(context, (Item) semanticObject); 
				return; 
			case Assignment2Package.LINE_ITEM:
				sequence_LineItem(context, (LineItem) semanticObject); 
				return; 
			case Assignment2Package.PRICE:
				sequence_Price(context, (Price) semanticObject); 
				return; 
			case Assignment2Package.STORE:
				sequence_Store(context, (Store) semanticObject); 
				return; 
			case Assignment2Package.TAX:
				sequence_Tax(context, (Tax) semanticObject); 
				return; 
			case Assignment2Package.TRANSACTION:
				sequence_Transaction(context, (Transaction) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AdditionalCharge returns AdditionalCharge
	 *
	 * Constraint:
	 *     serviceCharge=EDouble
	 */
	protected void sequence_AdditionalCharge(ISerializationContext context, AdditionalCharge semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Assignment2Package.Literals.ADDITIONAL_CHARGE__SERVICE_CHARGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Assignment2Package.Literals.ADDITIONAL_CHARGE__SERVICE_CHARGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionalChargeAccess().getServiceChargeEDoubleParserRuleCall_3_0(), semanticObject.getServiceCharge());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Address returns Address
	 *
	 * Constraint:
	 *     (street=EString? city=EString? country=EString? telephone=EString?)
	 */
	protected void sequence_Address(ISerializationContext context, Address semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Card returns Card
	 *
	 * Constraint:
	 *     (cardNumber=EString? expiryDate=EString? cardHolder=[Customer|EString])
	 */
	protected void sequence_Card(ISerializationContext context, Card semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cashier returns Cashier
	 *
	 * Constraint:
	 *     (name=EString surName=EString? employeeId=EString? customer=Customer? cashier=Cashier?)
	 */
	protected void sequence_Cashier(ISerializationContext context, Cashier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Company returns Company
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         codice=EString? 
	 *         address=Address? 
	 *         store+=Store 
	 *         store+=Store* 
	 *         (transaction+=Transaction transaction+=Transaction*)?
	 *     )
	 */
	protected void sequence_Company(ISerializationContext context, Company semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Customer returns Customer
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         surName=EString? 
	 *         identityNumber=EString? 
	 *         phoneNumber=EString? 
	 *         card=[Card|EString]? 
	 *         customer=Customer? 
	 *         cashier=Cashier?
	 *     )
	 */
	protected void sequence_Customer(ISerializationContext context, Customer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Discount returns Discount
	 *
	 * Constraint:
	 *     (percentage=EDouble amount=EDouble)
	 */
	protected void sequence_Discount(ISerializationContext context, Discount semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Assignment2Package.Literals.DISCOUNT__PERCENTAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Assignment2Package.Literals.DISCOUNT__PERCENTAGE));
			if (transientValues.isValueTransient(semanticObject, Assignment2Package.Literals.DISCOUNT__AMOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Assignment2Package.Literals.DISCOUNT__AMOUNT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDiscountAccess().getPercentageEDoubleParserRuleCall_3_0(), semanticObject.getPercentage());
		feeder.accept(grammarAccess.getDiscountAccess().getAmountEDoubleParserRuleCall_5_0(), semanticObject.getAmount());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Item returns Item
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         code=EString? 
	 *         batch=EString? 
	 *         description=EString? 
	 *         uom=UoM 
	 *         availableNumber=EDouble 
	 *         isActive=EBoolean 
	 *         unitPrice=Price
	 *     )
	 */
	protected void sequence_Item(ISerializationContext context, Item semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LineItem returns LineItem
	 *
	 * Constraint:
	 *     (
	 *         code=EString? 
	 *         quantity=EDouble 
	 *         item=[Item|EString] 
	 *         tax=Tax? 
	 *         discount=Discount? 
	 *         additionalCharge=AdditionalCharge?
	 *     )
	 */
	protected void sequence_LineItem(ISerializationContext context, LineItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Price returns Price
	 *
	 * Constraint:
	 *     sellingPrice=EDouble
	 */
	protected void sequence_Price(ISerializationContext context, Price semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Assignment2Package.Literals.PRICE__SELLING_PRICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Assignment2Package.Literals.PRICE__SELLING_PRICE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPriceAccess().getSellingPriceEDoubleParserRuleCall_3_0(), semanticObject.getSellingPrice());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Store returns Store
	 *
	 * Constraint:
	 *     (name=EString (item+=Item item+=Item*)?)
	 */
	protected void sequence_Store(ISerializationContext context, Store semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tax returns Tax
	 *
	 * Constraint:
	 *     (taxType=TaxType taxableAmount=EDouble taxAmount=EDouble)
	 */
	protected void sequence_Tax(ISerializationContext context, Tax semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Assignment2Package.Literals.TAX__TAX_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Assignment2Package.Literals.TAX__TAX_TYPE));
			if (transientValues.isValueTransient(semanticObject, Assignment2Package.Literals.TAX__TAXABLE_AMOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Assignment2Package.Literals.TAX__TAXABLE_AMOUNT));
			if (transientValues.isValueTransient(semanticObject, Assignment2Package.Literals.TAX__TAX_AMOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Assignment2Package.Literals.TAX__TAX_AMOUNT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTaxAccess().getTaxTypeTaxTypeEnumRuleCall_3_0(), semanticObject.getTaxType());
		feeder.accept(grammarAccess.getTaxAccess().getTaxableAmountEDoubleParserRuleCall_5_0(), semanticObject.getTaxableAmount());
		feeder.accept(grammarAccess.getTaxAccess().getTaxAmountEDoubleParserRuleCall_7_0(), semanticObject.getTaxAmount());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Transaction returns Transaction
	 *
	 * Constraint:
	 *     (
	 *         transactionNumber=EString? 
	 *         issuedDate=EDate? 
	 *         transactionType=TransactionType 
	 *         paymentMethod=PaymentMethod 
	 *         customer=Customer? 
	 *         cashier=Cashier? 
	 *         lineItem+=LineItem 
	 *         lineItem+=LineItem* 
	 *         card=Card?
	 *     )
	 */
	protected void sequence_Transaction(ISerializationContext context, Transaction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
